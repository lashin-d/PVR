Shader "Custom/RayMarching"
{
    Properties
    {
        _MaxDistance ("Max Distance", Float) = 50
        _MaxSteps ("Max Steps", Int) = 128
        _Epsilon ("Surface Epsilon", Float) = 0.001
    }

    SubShader
    {
        Tags { "RenderType"="Opaque" }
        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "UnityCG.cginc"

            struct appdata
            {
                float4 vertex : POSITION;
                float2 uv : TEXCOORD0;
            };

            struct v2f
            {
                float4 pos : SV_POSITION;
                float2 uv : TEXCOORD0;
            };

            float _MaxDistance;
            int _MaxSteps;
            float _Epsilon;

            // SDF
            float sdSphere(float3 p, float r)
            {
                return length(p) - r;
            }

            float sdBox(float3 p, float3 b)
            {
                float3 q = abs(p) - b;
                return length(max(q, 0)) + min(max(q.x, max(q.y, q.z)), 0);
            }
            
            float opUnion(float d1, float d2)
            {
                return min(d1, d2);
            }
            
            float opSubtraction(float d1, float d2)
            {
                return max(d1, -d2);
            }
            
            float opIntersection(float d1, float d2)
            {
                return max(d1, d2);
            }

            float map(float3 p)
            {
                // Підлога
                float ground = p.y + 1.0;

                // Сфера 1
                float sphere1 = sdSphere(p, 1.0);

                // Куб
                float box = sdBox(p - float3(2.0, 0.0, 0.0), float3(0.8, 0.8, 0.8));
                float sphereCut = sdSphere(p - float3(2.0, 0.0, 0.0), 0.9);
                float hollowBox = opSubtraction(box, sphereCut);

                // Сфера 2
                float sphere2 = sdSphere(p - float3(-2.0, 0.5, 0.0), 0.7);

                // Сцена
                float scene = opUnion(sphere1, hollowBox);
                scene = opUnion(scene, sphere2);
                scene = opUnion(scene, ground);
                return scene;
            }

            // RAY Marching
            float rayMarch(float3 ro, float3 rd)
            {
                float t = 0.0;

                for (int i = 0; i < _MaxSteps; i++)
                {
                    float3 p = ro + rd * t;
                    float d = map(p);

                    if (d < _Epsilon)
                        return t;

                    t += d;

                    if (t > _MaxDistance)
                    break;
                }

                return -1.0;
            }

            v2f vert(appdata v)
            {
                v2f o;
                o.pos = UnityObjectToClipPos(v.vertex);
                o.uv = v.uv;
                return o;
            }

            float3 calcNormal(float3 p)
            {
                float e = 0.001;
                float dx = map(p + float3(e, 0, 0)) - map(p - float3(e, 0, 0));
                float dy = map(p + float3(0, e, 0)) - map(p - float3(0, e, 0));
                float dz = map(p + float3(0, 0, e)) - map(p - float3(0, 0, e));
                return normalize(float3(dx, dy, dz));
            }

            float lambert(float3 n, float3 l)
            {
                return max(0, dot(n, l));
            }

            float phong(float3 n, float3 l, float3 v)
            {
                float3 r = reflect(-l, n);
                return pow(max(dot(v, r), 0), 32);
            }

            float softShadow(float3 ro, float3 rd, float maxDist)
            {
                float t = 0.02;
                float res = 1.0;
                for (int i = 0; i < 64; i++)
                {
                    float h = map(ro + rd * t);
                    if (h < _Epsilon)
                    return 0.0;
                    res = min(res, 10.0 * h / t);
                    t += h;
                    if (t > maxDist) break;
                }
                return saturate(res);
            }

            fixed4 frag(v2f i) : SV_Target
            {
                float2 uv = i.uv * 2.0 - 1.0;
                uv.x *= _ScreenParams.x / _ScreenParams.y;
                float3 ro = float3(0, 0, -4);
                float3 rd = normalize(float3(uv, 1));
                float t = rayMarch(ro, rd);
                if (t > 0)
                {
                    float3 p = ro + rd * t;
                    float3 normal = calcNormal(p);
                    float3 lightPos = float3(5, 5, -5);
                    float3 lightDir = normalize(lightPos - p);
                    float3 viewDir = normalize(ro - p);
                    float diff = lambert(normal, lightDir);
                    float spec = phong(normal, lightDir, viewDir);
                    float shadow = softShadow(p + normal * 0.01, lightDir, 10.0);
                    float3 color = float3(0.3, 0.6, 1.0);
                    float3 result = color * diff;
                    result += spec * 0.4;
                    result *= shadow;
                    result += 0.05;
                    return fixed4(result, 1);
                }
                return fixed4(0, 0, 0, 1);
            }
            ENDCG
        }
    }
}

